<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å°å°å‹‡å£«Â·é«˜ç©ºæ¢é™© ğŸŒˆ</title>
    <!-- å¼•å…¥ Three.js åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥ Tailwind CSS (ç”¨äº UI æ ·å¼) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ç¡®ä¿ Canvas å æ®æ•´ä¸ªè§†å£ */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(180deg, #FFE5B4 0%, #87CEEB 100%);
            font-family: 'Comic Sans MS', 'Inter', sans-serif;
            touch-action: none;
        }
        #game-canvas { display: block; width: 100%; height: 100%; }
        
        /* UI å®¹å™¨æ ·å¼ */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }
        
        /* æ¸¸æˆæŒ‰é’®é€šç”¨æ ·å¼ - å¢å¼ºè‰²å½© */
        .game-button {
            padding: 1rem 2.5rem;
            margin: 0.5rem;
            border-radius: 9999px;
            font-size: 1.25rem;
            font-weight: 900;
            color: white;
            transition: all 0.3s ease-in-out;
            box-shadow: 0 8px 0 rgba(0, 0, 0, 0.2), 0 4px 15px rgba(0, 0, 0, 0.15);
            pointer-events: auto;
            cursor: pointer;
            border: 4px solid rgba(255, 255, 255, 0.8);
            background: linear-gradient(145deg, var(--btn-color-1), var(--btn-color-2));
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }
        .game-button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            transform: rotate(45deg);
            animation: shine 3s infinite;
        }
        @keyframes shine {
            0%, 100% { transform: translateX(-100%) rotate(45deg); }
            50% { transform: translateX(100%) rotate(45deg); }
        }
        .game-button:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 12px 0 rgba(0, 0, 0, 0.2), 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        .game-button:active {
            transform: translateY(4px) scale(0.98);
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2), 0 2px 10px rgba(0, 0, 0, 0.15);
        }
        
        /* ç§»åŠ¨ç«¯æŒ‰é’®è°ƒæ•´ */
        @media (max-width: 768px) {
            .game-button {
                padding: 0.75rem 1.5rem;
                font-size: 1rem;
                margin: 0.25rem;
            }
            h1 { font-size: 2rem !important; }
            h2 { font-size: 1rem !important; }
        }
        
        /* æ¸¸æˆå¤±è´¥/æç¤ºæ¡† - æ›´æ´»æ³¼ */
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            padding: 1.5rem 2.5rem;
            background: linear-gradient(135deg, #FFF5E1, #FFE5B4);
            border-radius: 2rem;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            font-size: 1.5rem;
            font-weight: 900;
            color: #FF6B35;
            text-align: center;
            z-index: 100;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: none;
            border: 4px solid #FF6B35;
        }
        #message-box.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }
        
        /* è§’è‰²è¡¨æƒ…æ˜¾ç¤º */
        #player-mood {
            font-size: 4rem;
            line-height: 1;
            transition: transform 0.2s;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
            animation: bounce 2s infinite;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        /* ç§»åŠ¨ç«¯è™šæ‹Ÿæ§åˆ¶å™¨ */
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: grid;
            grid-template-columns: repeat(3, 70px);
            grid-template-rows: repeat(2, 70px);
            gap: 10px;
            pointer-events: auto;
            z-index: 50;
        }
        .control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: linear-gradient(145deg, #FFD700, #FFA500);
            border: 4px solid white;
            box-shadow: 0 6px 0 rgba(0, 0, 0, 0.2), 0 4px 15px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: white;
            cursor: pointer;
            touch-action: none;
            user-select: none;
            transition: all 0.1s;
        }
        .control-btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2), 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        .control-btn.up { grid-column: 2; grid-row: 1; }
        .control-btn.left { grid-column: 1; grid-row: 2; }
        .control-btn.right { grid-column: 3; grid-row: 2; }
        
        /* è¿›åº¦æ¡ */
        .progress-bar {
            width: 200px;
            height: 30px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            border: 3px solid #FF6B35;
            overflow: hidden;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FF6B35);
            transition: width 0.3s ease;
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.5);
        }
        
        /* æ˜Ÿæ˜Ÿé—ªçƒåŠ¨ç”» */
        @keyframes sparkle {
            0%, 100% { transform: scale(1) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.2) rotate(180deg); opacity: 0.8; }
        }
    </style>
</head>
<body>
    <canvas id="game-canvas"></canvas>

    <!-- åŠ è½½æç¤º -->
    <div id="loading" class="ui-overlay" style="background: linear-gradient(135deg, rgba(255,182,193,0.95), rgba(135,206,250,0.95));">
        <h2 class="text-3xl md:text-4xl font-extrabold" style="color: #FF6B35; text-shadow: 3px 3px 0 #FFD700;">
            ğŸ® åŠ è½½ä¸­...
        </h2>
        <p class="text-xl mt-4" style="color: #4169E1;">è¯·ç¨å€™</p>
    </div>

    <!-- ä¸»èœå• UI -->
    <div id="menu" class="ui-overlay hidden" style="background: linear-gradient(135deg, rgba(255,182,193,0.9), rgba(135,206,250,0.9));">
        <h1 class="text-5xl md:text-6xl font-extrabold mb-4 p-4 rounded-xl" style="color: #FF6B35; text-shadow: 4px 4px 0 #FFD700, 6px 6px 10px rgba(0,0,0,0.3);">
            ğŸŒˆ é«˜ç©ºæ¢é™©
        </h1>
        <p class="text-lg md:text-xl font-bold mb-10" style="color: #4169E1; text-shadow: 2px 2px 4px rgba(255,255,255,0.8);">
            æ”¶é›†æ˜Ÿæ˜Ÿâ­ å¯»æ‰¾å®ç®±ğŸ
        </p>

        <button class="game-button" style="--btn-color-1: #90EE90; --btn-color-2: #32CD32;" onclick="console.log('æŒ‰é’®1ç‚¹å‡»'); startGame(1);">
            ğŸŒ± è‰åœ°å†’é™©
        </button>
        <button class="game-button" style="--btn-color-1: #87CEEB; --btn-color-2: #4682B4;" onclick="console.log('æŒ‰é’®2ç‚¹å‡»'); startGame(2);">
            ğŸŒ‰ å½©è™¹æ¡¥
        </button>
        <button class="game-button" style="--btn-color-1: #DDA0DD; --btn-color-2: #BA55D3;" onclick="console.log('æŒ‰é’®3ç‚¹å‡»'); startGame(3);">
            â˜ï¸ äº‘ç«¯åŸå ¡
        </button>
    </div>

    <!-- æ¸¸æˆå†… UI -->
    <div id="game-ui" class="ui-overlay pointer-events-none hidden p-2 md:p-6">
        <!-- å·¦ä¸Šè§’: å‹‡æ°”å€¼/æ˜Ÿæ˜Ÿ -->
        <div class="absolute top-0 left-0 m-2 md:m-6 p-2 md:p-4 rounded-xl md:rounded-2xl shadow-xl pointer-events-auto flex items-center" 
             style="background: linear-gradient(135deg, rgba(255,215,0,0.95), rgba(255,165,0,0.95)); border: 3px solid #FF6B35;">
            <span class="text-2xl md:text-3xl mr-2 animate-pulse">â­</span>
            <span class="text-lg md:text-2xl font-black" style="color: #8B4513; text-shadow: 1px 1px 2px rgba(255,255,255,0.8);">
                <span id="courage-value">0</span> / 5
            </span>
        </div>
        
        <!-- å³ä¸Šè§’: å®ç®±æ”¶é›†æ•° -->
        <div class="absolute top-0 right-0 m-2 md:m-6 p-2 md:p-4 rounded-xl md:rounded-2xl shadow-xl pointer-events-auto flex items-center" 
             style="background: linear-gradient(135deg, rgba(255,182,193,0.95), rgba(255,105,180,0.95)); border: 3px solid #FF1493;">
            <span class="text-2xl md:text-3xl mr-2">ğŸ</span>
            <span class="text-lg md:text-2xl font-black" style="color: #8B0000; text-shadow: 1px 1px 2px rgba(255,255,255,0.8);">
                <span id="treasure-value">0</span>
            </span>
        </div>

        <!-- è§’è‰²å¿ƒæƒ…/è¡¨æƒ… -->
        <div class="absolute top-1/4 left-1/2 transform -translate-x-1/2 pointer-events-none">
            <div id="player-mood">ğŸ™‚</div>
        </div>
        
        <!-- å…³å¡è¿›åº¦æ¡ -->
        <div class="absolute top-16 md:top-24 left-1/2 transform -translate-x-1/2 pointer-events-auto">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill" style="width: 0%;"></div>
            </div>
            <p class="text-center text-sm md:text-base font-bold mt-1" style="color: #FF6B35; text-shadow: 1px 1px 2px rgba(255,255,255,0.8);">
                å‰è¿›è·ç¦»: <span id="distance-value">0</span>m
            </p>
        </div>

        <!-- æš‚åœ/è¿”å›æŒ‰é’® -->
        <button class="game-button text-base md:text-xl py-2 px-4 md:py-3 md:px-6 absolute top-2 right-2 md:top-6 md:right-6" 
                style="--btn-color-1: #708090; --btn-color-2: #2F4F4F;" onclick="pauseGame()">
            â¸ï¸
        </button>
        
        <!-- ç§»åŠ¨ç«¯è™šæ‹Ÿæ§åˆ¶å™¨ -->
        <div id="mobile-controls" class="mobile-controls hidden">
            <button class="control-btn up" ontouchstart="handleTouch('up', true)" ontouchend="handleTouch('up', false)">â¬†ï¸</button>
            <button class="control-btn left" ontouchstart="handleTouch('left', true)" ontouchend="handleTouch('left', false)">â¬…ï¸</button>
            <button class="control-btn right" ontouchstart="handleTouch('right', true)" ontouchend="handleTouch('right', false)">â¡ï¸</button>
        </div>
    </div>

    <!-- å¤±è´¥/æç¤ºæ¶ˆæ¯æ¡† -->
    <div id="message-box"></div>
    
    <!-- æš‚åœèœå• -->
    <div id="pause-menu" class="ui-overlay hidden" style="background: rgba(0, 0, 0, 0.85);">
        <div class="p-6 md:p-8 rounded-2xl max-w-md" style="background: linear-gradient(135deg, #FFE5B4, #FFF5E1); border: 4px solid #FF6B35;">
            <h2 class="text-3xl md:text-4xl font-extrabold mb-6" style="color: #FF6B35;">â¸ï¸ æš‚åœ</h2>
            <button class="game-button" style="--btn-color-1: #32CD32; --btn-color-2: #228B22;" onclick="resumeGame()">
                â–¶ï¸ ç»§ç»­
            </button>
            <button class="game-button" style="--btn-color-1: #FF6347; --btn-color-2: #DC143C;" onclick="restartGame()">
                ğŸ”„ é‡ç©
            </button>
            <button class="game-button" style="--btn-color-1: #A9A9A9; --btn-color-2: #696969;" onclick="showMenu()">
                ğŸ  ä¸»èœå•
            </button>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer;
        let player, mixer;
        const keyState = {};
        let isGameRunning = false;
        let isPaused = false;
        let currentScene = 1;
        let courageValue = 0;
        let treasureValue = 0;
        let distanceValue = 0;
        const playerSpeed = 0.08;
        let clouds = [];
        let treasures = [];
        let particles = [];
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // UI å…ƒç´ 
        const loadingEl = document.getElementById('loading');
        const menuEl = document.getElementById('menu');
        const gameUIEl = document.getElementById('game-ui');
        const pauseMenuEl = document.getElementById('pause-menu');
        const courageValueEl = document.getElementById('courage-value');
        const treasureValueEl = document.getElementById('treasure-value');
        const distanceValueEl = document.getElementById('distance-value');
        const progressFillEl = document.getElementById('progress-fill');
        const mobileControlsEl = document.getElementById('mobile-controls');
        const messageBoxEl = document.getElementById('message-box');
        const playerMoodEl = document.getElementById('player-mood');

        // è§’è‰²è¡¨æƒ…æ˜ å°„
        const moods = {
            'calm': 'ğŸ™‚',
            'nervous': 'ğŸ˜°',
            'walking': 'ğŸ˜Š',
            'success': 'ğŸ¤©',
            'surprised': 'ğŸ˜²'
        };
        
        // ç®€å•éŸ³æ•ˆåé¦ˆï¼ˆä½¿ç”¨Web Audio APIï¼‰
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(frequency = 440, duration = 0.1, type = 'sine') {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // --- æ ¸å¿ƒ Three.js åˆå§‹åŒ– ---

        function init() {
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

            // æ¸²æŸ“å™¨
            const canvas = document.getElementById('game-canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x87CEEB);

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // ç¯å…‰ - æ›´æ˜äº®
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = false;
            scene.add(directionalLight);
            
            // æ·»åŠ ç‚¹å…‰æºå¢åŠ è¶£å‘³æ€§
            const pointLight = new THREE.PointLight(0xFFD700, 0.5, 50);
            pointLight.position.set(0, 10, 0);
            scene.add(pointLight);

            // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', onWindowResize, false);
            
            // æ˜¾ç¤ºç§»åŠ¨ç«¯æ§åˆ¶å™¨
            if (isMobile) {
                mobileControlsEl.classList.remove('hidden');
            }

            // åˆå§‹è®¾ç½®èœå•
            showMenu();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- æ¸¸æˆå¯¹è±¡åˆ›å»º ---

        function createPlayer() {
            // Qç‰ˆå°äºº - æ›´å¯çˆ±çš„è®¾è®¡
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.0, 8);
            const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 6); // ä½¿ç”¨åœ†æŸ±ä½“ä»£æ›¿èƒ¶å›Š
            
            // å½©è™¹æ¸å˜æè´¨
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFEB3B });
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xFF6B35 });

            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            const head = new THREE.Mesh(headGeometry, headMaterial);
            
            // æ‰‹è‡‚ï¼ˆä½¿ç”¨åœ†æŸ±ä½“ï¼‰
            const armLeft = new THREE.Mesh(armGeometry, armMaterial);
            const armRight = new THREE.Mesh(armGeometry, armMaterial);

            head.position.y = 0.9;
            
            // æ‰‹è‡‚ä½ç½®å’Œæ—‹è½¬
            armLeft.position.set(-0.4, 0.2, 0);
            armLeft.rotation.z = Math.PI / 3;
            armRight.position.set(0.4, 0.2, 0);
            armRight.rotation.z = -Math.PI / 3;

            player = new THREE.Group();
            player.add(body);
            player.add(head);
            player.add(armLeft);
            player.add(armRight);

            player.position.set(0, 0.5, 0);
            player.name = 'player';
            scene.add(player);
            
            console.log('âœ… è§’è‰²åˆ›å»ºæˆåŠŸ');
        }

        function createStar(position) {
            // æ›´é—ªäº®çš„æ˜Ÿæ˜Ÿ
            const geometry = new THREE.OctahedronGeometry(0.35);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xFFD700,
                emissive: 0xFFAA00,
                emissiveIntensity: 0.5
            });
            const star = new THREE.Mesh(geometry, material);
            star.position.copy(position);
            star.name = 'star';
            
            // æ·»åŠ å¤–å…‰æ™•
            const glowGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFF00,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            star.add(glow);
            
            scene.add(star);

            // æ—‹è½¬å’Œç¼©æ”¾åŠ¨ç”»
            const starRotationClip = new THREE.AnimationClip('rotation', 2, [
                new THREE.VectorKeyframeTrack('.rotation', [0, 1, 2], [0, 0, 0, 0, Math.PI, 0, 0, Math.PI * 2, 0])
            ]);
            const starMixer = new THREE.AnimationMixer(star);
            const action = starMixer.clipAction(starRotationClip);
            action.play();

            star.mixer = starMixer;
            star.baseY = position.y;
            return star;
        }
        
        function createTreasure(position) {
            // å®ç®± - æ›´ç²¾è‡´
            const boxGeometry = new THREE.BoxGeometry(0.6, 0.5, 0.4);
            const lidGeometry = new THREE.BoxGeometry(0.65, 0.1, 0.45);
            const boxMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const lidMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            const lid = new THREE.Mesh(lidGeometry, lidMaterial);
            lid.position.y = 0.3;
            
            const treasure = new THREE.Group();
            treasure.add(box);
            treasure.add(lid);
            treasure.position.copy(position);
            treasure.name = 'treasure';
            
            // æ·»åŠ é—ªå…‰æ•ˆæœ
            const sparkleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const sparkleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.8
            });
            const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
            sparkle.position.y = 0.5;
            treasure.add(sparkle);
            
            scene.add(treasure);
            treasures.push(treasure);
            
            treasure.baseY = position.y;
            return treasure;
        }
        
        function createParticle(position, color = 0xFFD700) {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color, transparent: true });
            const particle = new THREE.Mesh(geometry, material);
            particle.position.copy(position);
            
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                Math.random() * 0.3 + 0.2,
                (Math.random() - 0.5) * 0.2
            );
            particle.life = 1.0;
            
            scene.add(particle);
            particles.push(particle);
        }
        
        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.velocity.clone().multiplyScalar(delta * 10));
                p.velocity.y -= delta * 2; // é‡åŠ›
                p.life -= delta;
                p.material.opacity = p.life;
                
                if (p.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        // --- åœºæ™¯ç”Ÿæˆå™¨ ---

        function createScene(level) {
            // æ¸…ç†æ—§åœºæ™¯å…ƒç´ 
            const toRemove = [];
            scene.children.forEach(child => {
                if (child.name !== 'player' && child.type !== 'AmbientLight' && 
                    child.type !== 'DirectionalLight' && child.type !== 'PointLight') {
                    toRemove.push(child);
                }
            });
            toRemove.forEach(child => scene.remove(child));
            
            // æ¸…ç†æ•°ç»„
            clouds = [];
            treasures = [];
            particles = [];
            
            // å¹³å°æè´¨ - æ›´é²œè‰³
            const woodMaterial = new THREE.MeshLambertMaterial({ color: 0xD2691E });
            const pathWidth = 4;
            const pathLength = 40;
            const starPositions = [];
            const treasurePositions = [];

            // é‡ç½®æ•°å€¼
            courageValue = 0;
            treasureValue = 0;
            distanceValue = 0;
            courageValueEl.textContent = '0';
            treasureValueEl.textContent = '0';
            distanceValueEl.textContent = '0';
            progressFillEl.style.width = '0%';

            switch (level) {
                case 1: // ğŸŒˆ åœºæ™¯ 1ï¼šè‰åœ°ç»ƒä¹ åŒº
                    renderer.setClearColor(0x87CEEB);
                    scene.fog.color.set(0x87CEEB);
                    camera.position.set(0, 4, 8);

                    // 1. ä¸»å¹³å°
                    const platform1 = new THREE.Mesh(
                        new THREE.BoxGeometry(pathWidth, 0.3, pathLength),
                        woodMaterial
                    );
                    platform1.position.set(0, 0, -pathLength / 2 + 10);
                    scene.add(platform1);

                    // 2. å½©è‰²è‰åœ°
                    const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x7CFC00 });
                    const grass = new THREE.Mesh(
                        new THREE.PlaneGeometry(100, 100),
                        grassMaterial
                    );
                    grass.rotation.x = -Math.PI / 2;
                    grass.position.y = -1.5;
                    scene.add(grass);
                    
                    // 3. æ·»åŠ èŠ±æœµè£…é¥°
                    for (let i = 0; i < 20; i++) {
                        const flowerColors = [0xFF69B4, 0xFFD700, 0xFF6347, 0x9370DB];
                        const flowerMaterial = new THREE.MeshBasicMaterial({ 
                            color: flowerColors[Math.floor(Math.random() * flowerColors.length)]
                        });
                        const flower = new THREE.Mesh(
                            new THREE.CircleGeometry(0.3, 6),
                            flowerMaterial
                        );
                        flower.rotation.x = -Math.PI / 2;
                        flower.position.set(
                            Math.random() * 40 - 20,
                            -1.4,
                            Math.random() * 40 - 20
                        );
                        scene.add(flower);
                    }
                    
                    // 4. æ·»åŠ æ ‘æœ¨
                    for (let i = 0; i < 8; i++) {
                        const treeGroup = new THREE.Group();
                        const trunk = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.4, 2, 8),
                            new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                        );
                        const leaves = new THREE.Mesh(
                            new THREE.SphereGeometry(1.5, 8, 8),
                            new THREE.MeshLambertMaterial({ color: 0x228B22 })
                        );
                        leaves.position.y = 2;
                        treeGroup.add(trunk);
                        treeGroup.add(leaves);
                        treeGroup.position.set(
                            Math.random() * 30 - 15,
                            -0.5,
                            Math.random() * 30 - 15
                        );
                        if (Math.abs(treeGroup.position.x) > pathWidth || 
                            Math.abs(treeGroup.position.z - (-pathLength/2 + 10)) > pathLength/2) {
                            scene.add(treeGroup);
                        }
                    }

                    // æ˜Ÿæ˜Ÿå’Œå®ç®±ä½ç½®
                    starPositions.push(new THREE.Vector3(0, 0.6, 8));
                    starPositions.push(new THREE.Vector3(1, 0.6, 0));
                    starPositions.push(new THREE.Vector3(-1, 0.6, -8));
                    starPositions.push(new THREE.Vector3(0, 0.6, -16));
                    starPositions.push(new THREE.Vector3(0, 0.6, -24));
                    
                    treasurePositions.push(new THREE.Vector3(1.5, 0.4, -4));
                    treasurePositions.push(new THREE.Vector3(-1.5, 0.4, -20));
                    break;

                case 2: // ğŸŒ¤ åœºæ™¯ 2ï¼šç©ºä¸­å½©è™¹æ¡¥
                    renderer.setClearColor(0xADD8E6);
                    scene.fog.color.set(0xADD8E6);
                    camera.position.set(0, 8, 10);

                    // 1. å½©è™¹æ¡¥
                    const bridgeHeight = 6;
                    const rainbowColors = [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3];
                    
                    for (let i = 0; i < 7; i++) {
                        const segment = new THREE.Mesh(
                            new THREE.BoxGeometry(pathWidth / 7, 0.4, pathLength),
                            new THREE.MeshLambertMaterial({ color: rainbowColors[i] })
                        );
                        segment.position.set(
                            -pathWidth/2 + pathWidth/7 * i + pathWidth/14,
                            bridgeHeight,
                            -pathLength / 2 + 10
                        );
                        scene.add(segment);
                    }
                    
                    // 2. æŠ¤æ 
                    const railMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                    for (let z = 10; z > -pathLength + 10; z -= 3) {
                        const railL = new THREE.Mesh(
                            new THREE.BoxGeometry(0.1, 1, 0.1),
                            railMaterial
                        );
                        railL.position.set(-pathWidth/2, bridgeHeight + 0.5, z);
                        scene.add(railL);
                        
                        const railR = new THREE.Mesh(
                            new THREE.BoxGeometry(0.1, 1, 0.1),
                            railMaterial
                        );
                        railR.position.set(pathWidth/2, bridgeHeight + 0.5, z);
                        scene.add(railR);
                    }

                    // 3. é£˜åŠ¨çš„äº‘æœµ
                    const cloudMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFFFFFF,
                        transparent: true,
                        opacity: 0.9
                    });
                    for (let i = 0; i < 25; i++) {
                        const cloudGroup = new THREE.Group();
                        for (let j = 0; j < 3; j++) {
                            const cloudPart = new THREE.Mesh(
                                new THREE.SphereGeometry(THREE.MathUtils.randFloat(0.8, 2), 8, 8),
                                cloudMaterial
                            );
                            cloudPart.position.set(
                                THREE.MathUtils.randFloat(-1, 1),
                                THREE.MathUtils.randFloat(-0.5, 0.5),
                                THREE.MathUtils.randFloat(-1, 1)
                            );
                            cloudGroup.add(cloudPart);
                        }
                        cloudGroup.position.set(
                            THREE.MathUtils.randFloat(-30, 30),
                            THREE.MathUtils.randFloat(bridgeHeight - 4, bridgeHeight + 2),
                            THREE.MathUtils.randFloat(-40, 20)
                        );
                        cloudGroup.userData.speed = THREE.MathUtils.randFloat(0.01, 0.03);
                        scene.add(cloudGroup);
                        clouds.push(cloudGroup);
                    }
                    
                    // 4. é£é¸Ÿ
                    for (let i = 0; i < 5; i++) {
                        const birdGeometry = new THREE.ConeGeometry(0.2, 0.5, 4);
                        const birdMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
                        const bird = new THREE.Mesh(birdGeometry, birdMaterial);
                        bird.position.set(
                            THREE.MathUtils.randFloat(-20, 20),
                            bridgeHeight + THREE.MathUtils.randFloat(2, 5),
                            THREE.MathUtils.randFloat(-30, 10)
                        );
                        bird.rotation.x = Math.PI / 2;
                        bird.userData.speed = THREE.MathUtils.randFloat(0.02, 0.05);
                        bird.userData.radius = THREE.MathUtils.randFloat(5, 10);
                        bird.userData.angle = Math.random() * Math.PI * 2;
                        scene.add(bird);
                        clouds.push(bird); // å¤ç”¨cloudsæ•°ç»„åšåŠ¨ç”»
                    }

                    // æ˜Ÿæ˜Ÿå’Œå®ç®±ä½ç½®
                    starPositions.push(new THREE.Vector3(0, bridgeHeight + 0.6, 8));
                    starPositions.push(new THREE.Vector3(1, bridgeHeight + 0.6, 0));
                    starPositions.push(new THREE.Vector3(-1, bridgeHeight + 0.6, -8));
                    starPositions.push(new THREE.Vector3(0, bridgeHeight + 0.6, -16));
                    starPositions.push(new THREE.Vector3(0, bridgeHeight + 0.6, -24));
                    
                    treasurePositions.push(new THREE.Vector3(1.5, bridgeHeight + 0.4, -4));
                    treasurePositions.push(new THREE.Vector3(-1.5, bridgeHeight + 0.4, -12));
                    treasurePositions.push(new THREE.Vector3(0, bridgeHeight + 0.4, -28));
                    break;
                
                case 3: // â˜ï¸ åœºæ™¯ 3ï¼šäº‘ç«¯åŸå ¡
                    renderer.setClearColor(0xFFB6C1);
                    scene.fog.color.set(0xFFB6C1);
                    camera.position.set(0, 18, 12);

                    // 1. å¤šä¸ªæ¼‚æµ®å¹³å°
                    const platformY = 16;
                    const platformColors = [0xFF69B4, 0xDDA0DD, 0x9370DB, 0xFFD700, 0xFF6347];
                    const rainbowColorsLevel3 = [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3];
                    
                    const platforms = [
                        { size: [6, 0.5, 6], pos: [0, platformY, 8] },
                        { size: [5, 0.5, 5], pos: [0, platformY, 0] },
                        { size: [4, 0.5, 6], pos: [0, platformY + 0.5, -8] },
                        { size: [5, 0.5, 5], pos: [5, platformY + 1, -16] },
                        { size: [6, 0.5, 6], pos: [0, platformY + 1.5, -24] }
                    ];
                    
                    platforms.forEach((p, i) => {
                        const platform = new THREE.Mesh(
                            new THREE.BoxGeometry(...p.size),
                            new THREE.MeshLambertMaterial({ color: platformColors[i % platformColors.length] })
                        );
                        platform.position.set(...p.pos);
                        scene.add(platform);
                    });
                    
                    // 2. åŸå ¡å¡”æ¥¼è£…é¥°
                    const towerMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
                    for (let i = 0; i < 3; i++) {
                        const tower = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.5, 0.7, 4, 8),
                            towerMaterial
                        );
                        const roof = new THREE.Mesh(
                            new THREE.ConeGeometry(0.8, 1.5, 8),
                            new THREE.MeshLambertMaterial({ color: 0xFF1493 })
                        );
                        roof.position.y = 2.75;
                        
                        const towerGroup = new THREE.Group();
                        towerGroup.add(tower);
                        towerGroup.add(roof);
                        towerGroup.position.set(
                            (i - 1) * 4,
                            platformY - 1.5,
                            -28
                        );
                        scene.add(towerGroup);
                    }

                    // 3. å¤šå±‚äº‘æµ·
                    for (let layer = 0; layer < 3; layer++) {
                        const cloudY = platformY - 5 - layer * 3;
                        const cloudLayerMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFFFF,
                            transparent: true,
                            opacity: 0.7 - layer * 0.1
                        });
                        
                        for (let i = 0; i < 30; i++) {
                            const cloudGroup = new THREE.Group();
                            for (let j = 0; j < 4; j++) {
                                const cloudPart = new THREE.Mesh(
                                    new THREE.SphereGeometry(THREE.MathUtils.randFloat(1.5, 3), 8, 8),
                                    cloudLayerMaterial
                                );
                                cloudPart.position.set(
                                    THREE.MathUtils.randFloat(-2, 2),
                                    THREE.MathUtils.randFloat(-1, 1),
                                    THREE.MathUtils.randFloat(-2, 2)
                                );
                                cloudGroup.add(cloudPart);
                            }
                            cloudGroup.position.set(
                                THREE.MathUtils.randFloat(-40, 40),
                                cloudY,
                                THREE.MathUtils.randFloat(-50, 30)
                            );
                            cloudGroup.userData.speed = THREE.MathUtils.randFloat(0.005, 0.02);
                            cloudGroup.userData.layer = layer;
                            scene.add(cloudGroup);
                            clouds.push(cloudGroup);
                        }
                    }
                    
                    // 4. æ¼‚æµ®çš„æ˜Ÿæ˜Ÿè£…é¥°
                    for (let i = 0; i < 10; i++) {
                        const decorStar = new THREE.Mesh(
                            new THREE.OctahedronGeometry(0.3),
                            new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.7 })
                        );
                        decorStar.position.set(
                            THREE.MathUtils.randFloat(-15, 15),
                            platformY + THREE.MathUtils.randFloat(3, 8),
                            THREE.MathUtils.randFloat(-30, 10)
                        );
                        scene.add(decorStar);
                    }
                    
                    // 5. å½©è™¹
                    const rainbowRadius = 20;
                    for (let i = 0; i < 7; i++) {
                        const arc = new THREE.Mesh(
                            new THREE.TorusGeometry(rainbowRadius + i * 0.5, 0.3, 8, 50, Math.PI),
                            new THREE.MeshBasicMaterial({ 
                                color: rainbowColorsLevel3[i],
                                transparent: true,
                                opacity: 0.8
                            })
                        );
                        arc.position.set(15, platformY, -40);
                        arc.rotation.y = Math.PI / 6;
                        scene.add(arc);
                    }

                    // æ˜Ÿæ˜Ÿå’Œå®ç®±ä½ç½®
                    starPositions.push(new THREE.Vector3(0, platformY + 0.6, 6));
                    starPositions.push(new THREE.Vector3(0, platformY + 0.6, -2));
                    starPositions.push(new THREE.Vector3(0, platformY + 1.1, -8));
                    starPositions.push(new THREE.Vector3(5, platformY + 1.6, -16));
                    starPositions.push(new THREE.Vector3(0, platformY + 2.1, -24));
                    
                    treasurePositions.push(new THREE.Vector3(2, platformY + 0.4, 4));
                    treasurePositions.push(new THREE.Vector3(-2, platformY + 0.4, -4));
                    treasurePositions.push(new THREE.Vector3(3, platformY + 1.4, -14));
                    treasurePositions.push(new THREE.Vector3(-2, platformY + 1.9, -22));
                    break;
            }

            // æ”¾ç½®æ˜Ÿæ˜Ÿå’Œå®ç®±
            starPositions.forEach(pos => createStar(pos));
            treasurePositions.forEach(pos => createTreasure(pos));

            // å°†ç©å®¶ç§»åˆ°èµ·ç‚¹
            if (level === 1) player.position.set(0, 0.5, 8);
            if (level === 2) player.position.set(0, 6.5, 8);
            if (level === 3) player.position.set(0, 16.5, 6);
            
            // æ’­æ”¾å¼€å§‹éŸ³æ•ˆ
            playSound(523, 0.1, 'sine');
            playSound(659, 0.1, 'sine');
        }


        // --- UI äº¤äº’é€»è¾‘ ---

        function showMenu() {
            isGameRunning = false;
            isPaused = false;
            loadingEl.classList.add('hidden');
            menuEl.classList.remove('hidden');
            pauseMenuEl.classList.add('hidden');
            gameUIEl.classList.add('hidden');
            messageBoxEl.classList.remove('show');
        }

        function startGame(level) {
            console.log('ğŸ® å¼€å§‹æ¸¸æˆï¼Œå…³å¡:', level);
            
            // ç¡®ä¿playerå·²åˆ›å»º
            if (!player) {
                console.error('âŒ Player è¿˜æœªåˆ›å»ºï¼Œè¯·ç¨åé‡è¯•');
                setTimeout(() => startGame(level), 100);
                return;
            }
            
            try {
                currentScene = level;
                createScene(level);
                console.log('âœ… å…³å¡', level, 'åˆ›å»ºæˆåŠŸ');
            } catch (error) {
                console.error('âŒ å…³å¡åˆ›å»ºå¤±è´¥:', error);
                showMessage('å…³å¡åŠ è½½å¤±è´¥: ' + error.message, 3000, '#FF0000');
                showMenu();
                return;
            }
            
            // éšè—èœå•ï¼Œæ˜¾ç¤ºæ¸¸æˆ UI
            menuEl.classList.add('hidden');
            pauseMenuEl.classList.add('hidden');
            gameUIEl.classList.remove('hidden');
            
            // æ˜¾ç¤ºç§»åŠ¨ç«¯æ§åˆ¶
            if (isMobile) {
                mobileControlsEl.classList.remove('hidden');
            }

            isGameRunning = true;
            isPaused = false;
            playerMoodEl.textContent = moods.calm;
            
            // æ˜¾ç¤ºæç¤º
            const tips = [
                'â­ æ”¶é›†æ‰€æœ‰æ˜Ÿæ˜Ÿï¼',
                'ğŸ å¯»æ‰¾éšè—çš„å®ç®±ï¼',
                'â˜ï¸ ä¸è¦å®³æ€•æ‰ä¸‹å»ï½'
            ];
            showMessage(tips[Math.floor(Math.random() * tips.length)], 2500, '#32CD32');
        }
        
        function pauseGame() {
            if (!isGameRunning) return;
            isPaused = true;
            isGameRunning = false;
            gameUIEl.classList.add('hidden');
            pauseMenuEl.classList.remove('hidden');
            playSound(440, 0.1, 'square');
        }
        
        function resumeGame() {
            if (isPaused) {
                isPaused = false;
                isGameRunning = true;
                pauseMenuEl.classList.add('hidden');
                gameUIEl.classList.remove('hidden');
                playSound(523, 0.1, 'sine');
            }
        }
        
        function restartGame() {
            startGame(currentScene);
        }

        function showMessage(text, duration = 3000, color = '#FF6B35') {
            messageBoxEl.innerHTML = text;
            messageBoxEl.style.color = color;
            messageBoxEl.classList.add('show');
            setTimeout(() => {
                messageBoxEl.classList.remove('show');
            }, duration);
        }
        
        // ç§»åŠ¨ç«¯è§¦æ‘¸æ§åˆ¶
        function handleTouch(direction, isPressed) {
            const keyMap = {
                'up': 'w',
                'left': 'a',
                'right': 'd'
            };
            keyState[keyMap[direction]] = isPressed;
            
            if (isPressed) {
                playSound(440, 0.05, 'square');
            }
        }


        // --- æ¸¸æˆé€»è¾‘ ---

        function handleControls() {
            if (!isGameRunning) return;

            let moveX = 0;
            let moveZ = 0;
            let isMoving = false;

            // WASD æˆ–æ–¹å‘é”®æ§åˆ¶
            if (keyState['ArrowUp'] || keyState['w'] || keyState['arrowup']) {
                moveZ -= 1;
                isMoving = true;
            }
            if (keyState['ArrowLeft'] || keyState['a'] || keyState['arrowleft']) {
                moveX -= 1;
                isMoving = true;
            }
            if (keyState['ArrowRight'] || keyState['d'] || keyState['arrowright']) {
                moveX += 1;
                isMoving = true;
            }

            // è®¡ç®—é€Ÿåº¦
            let currentSpeed = playerSpeed;

            if (isMoving) {
                // å½’ä¸€åŒ–ç§»åŠ¨å‘é‡
                const magnitude = Math.sqrt(moveX * moveX + moveZ * moveZ);
                moveX /= magnitude;
                moveZ /= magnitude;
                
                // ç§»åŠ¨ç©å®¶
                player.position.x += moveX * currentSpeed;
                player.position.z += moveZ * currentSpeed;
                
                // æ›´æ–°è·ç¦»ï¼ˆåªæœ‰å‘å‰ç§»åŠ¨æ‰è®¡ç®—ï¼‰
                if (moveZ < 0) {
                    distanceValue += Math.abs(moveZ * currentSpeed * 10);
                    distanceValueEl.textContent = Math.floor(distanceValue);
                    
                    // æ›´æ–°è¿›åº¦æ¡ï¼ˆå‡è®¾ç›®æ ‡æ˜¯30ç±³ï¼‰
                    const progress = Math.min((distanceValue / 30) * 100, 100);
                    progressFillEl.style.width = progress + '%';
                }

                // è§’è‰²åŠ¨ç”» - è½»å¾®æ™ƒåŠ¨
                player.rotation.z = Math.sin(Date.now() * 0.01) * 0.05;
                
                // è°ƒæ•´è¡¨æƒ…
                playerMoodEl.textContent = moods.walking;
            } else {
                // åœæ­¢æ—¶ï¼Œæ ¹æ®é«˜åº¦è°ƒæ•´è¡¨æƒ…
                player.rotation.z = 0;
                const currentY = player.position.y;
                if (currentY > 12) {
                    playerMoodEl.textContent = moods.nervous;
                } else {
                    playerMoodEl.textContent = moods.calm;
                }
            }
            
            // é™åˆ¶Xè½´ç§»åŠ¨èŒƒå›´
            const maxX = 3;
            player.position.x = Math.max(-maxX, Math.min(maxX, player.position.x));
        }

        function checkCollisions() {
            const playerPos = player.position;
            const playerRadius = 0.6;
            
            // 1. æ‰è½æ£€æµ‹
            let safeY = 0;
            if (currentScene === 1) safeY = 0;
            if (currentScene === 2) safeY = 6;
            if (currentScene === 3) safeY = 16;
            
            const dropThreshold = safeY - 4;

            if (playerPos.y < dropThreshold) {
                // æ‰è½æ•ˆæœ
                showMessage('â˜ï¸ æ²¡å…³ç³»ï¼äº‘æœµä¼šæ‰˜ä½ä½ ï½', 2500, '#87CEEB');
                playerMoodEl.textContent = moods.surprised;
                playSound(330, 0.3, 'sine');
                
                // é—ªç™½æ•ˆæœ
                renderer.setClearColor(0xFFFFFF);
                setTimeout(() => {
                    // é‡ç½®ä½ç½®
                    if (currentScene === 1) {
                        player.position.set(0, 0.5, 8);
                        renderer.setClearColor(0x87CEEB);
                    }
                    if (currentScene === 2) {
                        player.position.set(0, 6.5, 8);
                        renderer.setClearColor(0xADD8E6);
                    }
                    if (currentScene === 3) {
                        player.position.set(0, 16.5, 6);
                        renderer.setClearColor(0xFFB6C1);
                    }
                    playerMoodEl.textContent = moods.calm;
                }, 600);
                
                return;
            }

            // 2. æ˜Ÿæ˜Ÿæ”¶é›†
            const stars = scene.children.filter(c => c.name === 'star');
            stars.forEach(star => {
                const distance = playerPos.distanceTo(star.position);
                if (distance < playerRadius + 0.5) {
                    // æ”¶é›†æˆåŠŸ
                    scene.remove(star);
                    courageValue++;
                    courageValueEl.textContent = courageValue;
                    showMessage('â­ å‹‡æ°”å€¼ +1ï¼å¤ªæ£’äº†ï¼', 1500, '#FFD700');
                    playerMoodEl.textContent = moods.success;
                    playSound(659, 0.15, 'sine');
                    playSound(784, 0.15, 'sine');
                    
                    // ç²’å­æ•ˆæœ
                    for (let i = 0; i < 10; i++) {
                        createParticle(star.position.clone(), 0xFFD700);
                    }
                    
                    setTimeout(() => {
                        if (isGameRunning) playerMoodEl.textContent = moods.walking;
                    }, 1000);

                    // èƒœåˆ©æ£€æµ‹
                    if (courageValue >= 5) {
                        showMessage('ğŸ‰ æ­å–œé€šå…³ï¼ä½ çœŸæ˜¯ä¸ªå‹‡æ•¢çš„å°å‹‡å£«ï¼ğŸ†', 5000, '#32CD32');
                        playerMoodEl.textContent = moods.success;
                        playSound(523, 0.2, 'sine');
                        playSound(659, 0.2, 'sine');
                        playSound(784, 0.2, 'sine');
                        
                        // èƒœåˆ©ç²’å­æ•ˆæœ
                        for (let i = 0; i < 30; i++) {
                            setTimeout(() => {
                                createParticle(
                                    playerPos.clone().add(new THREE.Vector3(
                                        (Math.random() - 0.5) * 2,
                                        Math.random() * 2,
                                        (Math.random() - 0.5) * 2
                                    )),
                                    [0xFFD700, 0xFF69B4, 0x87CEEB, 0x32CD32][Math.floor(Math.random() * 4)]
                                );
                            }, i * 50);
                        }
                        
                        isGameRunning = false;
                        setTimeout(showMenu, 6000);
                    }
                }
            });
            
            // 3. å®ç®±æ”¶é›†
            treasures.forEach((treasure, index) => {
                if (!treasure.parent) return; // å·²è¢«æ”¶é›†
                const distance = playerPos.distanceTo(treasure.position);
                if (distance < playerRadius + 0.6) {
                    scene.remove(treasure);
                    treasureValue++;
                    treasureValueEl.textContent = treasureValue;
                    showMessage('ğŸ å‘ç°å®ç®±ï¼+1', 1500, '#FF69B4');
                    playerMoodEl.textContent = moods.success;
                    playSound(784, 0.15, 'triangle');
                    playSound(880, 0.15, 'triangle');
                    
                    // å®ç®±ç²’å­æ•ˆæœ
                    for (let i = 0; i < 15; i++) {
                        createParticle(treasure.position.clone(), 0xFFD700);
                    }
                    
                    setTimeout(() => {
                        if (isGameRunning) playerMoodEl.textContent = moods.walking;
                    }, 1000);
                }
            });
        }

        function updateCamera() {
            const targetPos = player.position;
            
            // åŠ¨æ€ç›¸æœºåç§»
            let offsetX = player.position.x * 0.2; // è½»å¾®è·ŸéšXè½´
            let offsetY = 4;
            let offsetZ = 6;

            // æ ¹æ®åœºæ™¯è°ƒæ•´
            if (currentScene === 2) {
                offsetY = 5;
                offsetZ = 8;
            }
            if (currentScene === 3) {
                offsetY = 6;
                offsetZ = 10;
            }
            
            const cameraTargetX = targetPos.x + offsetX;
            const cameraTargetY = targetPos.y + offsetY;
            const cameraTargetZ = targetPos.z + offsetZ;

            // å¹³æ»‘è·Ÿéš
            const smoothness = 0.08;
            camera.position.x += (cameraTargetX - camera.position.x) * smoothness;
            camera.position.y += (cameraTargetY - camera.position.y) * smoothness;
            camera.position.z += (cameraTargetZ - camera.position.z) * smoothness;

            camera.lookAt(targetPos.x, targetPos.y + 0.5, targetPos.z);
        }
        
        function updateEnvironment(delta) {
            // äº‘æœµå’Œç¯å¢ƒåŠ¨ç”»
            clouds.forEach(cloud => {
                if (cloud.geometry && cloud.geometry.type === 'ConeGeometry') {
                    // é¸Ÿç±»é£è¡Œ
                    cloud.userData.angle += cloud.userData.speed;
                    const radius = cloud.userData.radius;
                    cloud.position.x = Math.cos(cloud.userData.angle) * radius;
                    cloud.position.z = Math.sin(cloud.userData.angle) * radius - 10;
                    cloud.rotation.y = cloud.userData.angle + Math.PI / 2;
                } else {
                    // äº‘æœµæ¼‚ç§»
                    cloud.position.x += cloud.userData.speed;
                    if (cloud.position.x > 50) cloud.position.x = -50;
                }
            });
            
            // æ˜Ÿæ˜Ÿä¸Šä¸‹æµ®åŠ¨å’Œæ—‹è½¬
            scene.children.filter(c => c.name === 'star').forEach(star => {
                if (star.mixer) star.mixer.update(delta);
                star.position.y = star.baseY + Math.sin(Date.now() * 0.003) * 0.2;
                star.rotation.y += delta * 2;
            });
            
            // å®ç®±ä¸Šä¸‹æµ®åŠ¨å’Œé—ªå…‰
            treasures.forEach(treasure => {
                if (!treasure.parent) return;
                treasure.position.y = treasure.baseY + Math.sin(Date.now() * 0.002) * 0.15;
                treasure.rotation.y += delta * 0.5;
                
                // é—ªå…‰æ•ˆæœ
                const sparkle = treasure.children[2];
                if (sparkle) {
                    sparkle.scale.setScalar(1 + Math.sin(Date.now() * 0.01) * 0.5);
                }
            });
            
            // æ›´æ–°ç²’å­
            updateParticles(delta);
        }
        
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            
            if (isGameRunning) {
                handleControls();
                checkCollisions();
                updateCamera();
            }
            
            // ç¯å¢ƒåŠ¨ç”»å§‹ç»ˆè¿è¡Œ
            updateEnvironment(delta);

            renderer.render(scene, camera);
        }

        // --- äº‹ä»¶ç›‘å¬ ---

        function handleKeyDown(event) {
            const key = event.key.toLowerCase();
            keyState[key] = true;
            
            // é˜»æ­¢æ–¹å‘é”®æ»šåŠ¨é¡µé¢
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd', ' '].includes(key)) {
                event.preventDefault();
            }
            
            // ç©ºæ ¼é”®æš‚åœ/æ¢å¤
            if (key === ' ' && isGameRunning) {
                pauseGame();
            } else if (key === ' ' && isPaused) {
                resumeGame();
            }
        }

        function handleKeyUp(event) {
            keyState[event.key.toLowerCase()] = false;
        }

        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        
        // é˜²æ­¢ä¸Šä¸‹æ–‡èœå•
        window.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // è§¦æ‘¸äº‹ä»¶é˜²æ­¢ç¼©æ”¾
        document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });

        // åˆå§‹åŒ–æ¸¸æˆ
        window.addEventListener('DOMContentLoaded', function () {
            console.log('ğŸ® æ¸¸æˆåˆå§‹åŒ–ä¸­...');
            
            // æ£€æŸ¥Three.jsæ˜¯å¦åŠ è½½
            if (typeof THREE === 'undefined') {
                console.error('âŒ Three.js æœªåŠ è½½ï¼');
                alert('æ¸¸æˆåŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                return;
            }
            
            try {
                init();
                createPlayer();
                animate();
                console.log('âœ… æ¸¸æˆå·²åŠ è½½å®Œæˆï¼å¯ä»¥ç‚¹å‡»æŒ‰é’®å¼€å§‹æ¸¸æˆ');
            } catch (error) {
                console.error('âŒ æ¸¸æˆåˆå§‹åŒ–å¤±è´¥:', error);
                alert('æ¸¸æˆåˆå§‹åŒ–å¤±è´¥: ' + error.message);
            }
        });
    </script>
</body>
</html>